snippet derive
	#[derive(Debug$0)]

snippet les
	let $1 = $2 else {
		return $0;
	}

snippet uvec
	Vec::new()

snippet tack
  |tok: &Token, _: &[char]| $0

snippet normlint 
  use itertools::Itertools;
  
  use crate::{
      patterns::{Pattern, SequencePattern, WordPatternGroup},
      Lrc, Token, TokenStringExt,
      Document, Span
  };
  
  use super::{Linter, Lint, LintKind, PatternLinter, Suggestion};
  
  pub struct $1 {
  }
  
  impl Linter for $1 {
    fn lint(&mut self, document: &Document) -> Vec<Lint>{

    }

    fn description(&self) -> &str {

    }
 }
  
  #[cfg(test)]
  mod tests {
    use super::$1;
  }

snippet modtest
  #[cfg(test)]
  mod tests {
    $0
  }

snippet test
  #[test]
  fn $1() {
    $0
  }

snippet testsg
  #[test]
  fn $1() {
      assert_suggestion_result(
          "$2",
          $3::default(),
          "$0",
      );
  }

snippet explint
  use crate::expr::Expr;
  use crate::expr::LongestMatchOf;
  use crate::expr::SequenceExpr;
  use crate::{Token, TokenStringExt};
  
  use super::{ExprLinter, Lint, LintKind, Suggestion};
  
  pub struct $1 {
      expr: Box<dyn Expr>,
  }
  
  impl Default for $1 {
      fn default() -> Self {
        let expr = $2;
  
          Self {
              expr: Box::new(expr),
          }
      }
  }
  
  impl ExprLinter for $1 {
      fn expr(&self) -> &dyn Expr {
          self.expr.as_ref()
      }
  
      fn match_to_lint(&self, matched_tokens: &[Token], _source: &[char]) -> Option<Lint> {
          unimplemented!()
      }
  
      fn description(&self) -> &'static str {
          unimplemented!()
      }
  }
  
  #[cfg(test)]
  mod tests {
  }

snippet asl
  assert_no_lints($1, $0);
